#!/usr/bin/env ruby

require 'optparse'
require 'fileutils'

symfony_app_path = 'app'
capifony_version = '3.0.0.dev'

OptionParser.new do |opts|
  opts.banner = "Usage: #{File.basename($0)} [path]"

  opts.on("-h", "--help", "Displays this help info") do
    puts opts
    exit 0
  end

  opts.on("-v", "--version", "") do
    puts "capifony v#{capifony_version}"
    exit 0
  end

  opts.on("-p", "--app NAME", "Specify app name (folder) to capify") do |path|
    symfony_app_path = path
  end

  begin
    opts.parse!(ARGV)
  rescue OptionParser::ParseError => e
    warn e.message
    puts opts
    exit 1
  end
end

if ARGV.empty?
  abort "Please specify the directory to capifony, e.g. `#{File.basename($0)} .'"
elsif !File.exists?(ARGV.first)
  abort "`#{ARGV.first}' does not exist."
elsif !File.directory?(ARGV.first)
  abort "`#{ARGV.first}' is not a directory."
elsif ARGV.length > 1
  abort "Too many arguments; please specify only the directory to capifony."
end

def unindent(string)
  indentation = string[/\A\s*/]
  string.strip.gsub(/^#{indentation}/, "")
end

base = ARGV.shift

files = {
  "Capfile" => unindent(<<-FILE),
    # Load DSL and Setup Up Stages
    require 'capistrano/setup'
    # Includes default deployment tasks
    require 'capistrano/deploy'
    # Symfony tasks!
    require 'capistrano/symfony'

    # Loads custom tasks from `lib/capistrano/tasks' if you have any defined.
    Dir.glob('lib/capistrano/tasks/*.cap').each { |r| import r }
  FILE

  "config/deploy.rb" => unindent(<<-FILE),
    set :application, "your application name"
    set :repo_url, "git@github.com:org/your_repository.git"
    # set :deploy_to, "/var/www/app_path"

    # ask :branch, proc { `git rev-parse --abbrev-ref HEAD`.chomp }

    # set :scm, :git

    # set :format, :pretty
    # set :log_level, :debug
    # set :pty, true

    # set :linked_files, %w{app/config/parameters.yml}
    # set :linked_dirs, %w{app/logs web/uploads}
    # set :writable_dirs %w{app/logs app/cache}
    # set :permission_method, :acl

    # set :keep_releases, 5
  FILE

  "config/deploy/production.rb" => unindent(<<-FILE),
    set :stage, :production

    # Simple Role Syntax
    # ==================
    # Supports bulk-adding hosts to roles, the primary
    # server in each group is considered to be the first
    # unless any hosts have the primary property set.
    role :app, %w{deploy@example.com}
    role :web, %w{deploy@example.com}
    role :db,  %w{deploy@example.com}

    # Extended Server Syntax
    # ======================
    # This can be used to drop a more detailed server
    # definition into the server list. The second argument
    # something that quacks like a has can be used to set
    # extended properties on the server.
    server 'example.com', user: 'deploy', roles: %w{web app}, my_property: :my_value

    # you can set custom ssh options
    # it's possible to pass any option but you need to keep in mind that net/ssh understand limited list of options
    # you can see them in [net/ssh documentation](http://net-ssh.github.io/net-ssh/classes/Net/SSH.html#method-c-start)
    # set it globally
    #  set :ssh_options, {
    #    keys: %w(/home/rlisowski/.ssh/id_rsa),
    #    forward_agent: false,
    #    auth_methods: %w(password)
    #  }
    # and/or per server
    # server 'example.com',
    #   user: 'user_name',
    #   roles: %w{web app},
    #   ssh_options: {
    #     user: 'user_name', # overrides user setting above
    #     keys: %w(/home/user_name/.ssh/id_rsa),
    #     forward_agent: false,
    #     auth_methods: %w(publickey password)
    #     # password: 'please use keys'
    #   }
    # setting per server overrides global ssh_options

    # fetch(:default_env).merge!(:rails_env, :production)
  FILE
}

files.each do |file, content|
  file = File.join(base, file)
  if File.exists?(file)
    warn "[skip] '#{file}' already exists"
  elsif File.exists?(file.downcase)
    warn "[skip] '#{file.downcase}' exists, which could conflict with `#{file}'"
  else
    unless File.exists?(File.dirname(file))
      puts "[add] making directory '#{File.dirname(file)}'"
      FileUtils.mkdir_p(File.dirname(file))
    end
    puts "[add] writing '#{file}'"
    File.open(file, "w") { |f| f.write(content) }
  end
end

puts "[done] project capifonied!"
